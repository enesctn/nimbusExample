"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Navigator = void 0;
const actions_1 = require("@zup-it/nimbus-backend-core/actions");
const lodash_1 = require("lodash");
const navigationActions = { push: actions_1.push, popTo: actions_1.popTo, pop: actions_1.pop, present: actions_1.present, dismiss: actions_1.dismiss };
/**
 * See the property `navigation` in the interface `ScreenProps` for a detailed description of the Navigator.
 *
 * The instance of the current navigator is injected by the NimbusApplication for every registered Screen.
 *
 * @example
 * ```tsx
 * const MyScreen: Screen<Type> = ({ navigator }) => {
 *   // ...
 * }
 * ```
 */
class Navigator {
    /**
     * @param routeMap the same routeMap received by NimbusApplication.
     * @param basePath the same navigatorBasePath received by NimbusApplication options, if none, options.basePath is
     * used.
     */
    constructor(routeMap, basePath) {
        this.screenMap = new Map();
        this.basePath = basePath ?? '';
        (0, lodash_1.forEach)(routeMap, (value, key) => this.screenMap.set(typeof value === 'function' ? value : value.screen, { path: key, method: typeof value === 'function' ? undefined : value.method }));
    }
    screenMap;
    basePath;
    getPathAndMethod(screen) {
        if (!this.screenMap.has(screen)) {
            throw new Error("Couldn't find any route corresponding to the provided screen. Are you sure you registered it in the route map provided to the NimbusApp?");
        }
        return this.screenMap.get(screen);
    }
    buildUrl(path, routeParams = {}, query) {
        const withRouteParams = path.replace(/:(\w+)/g, (_, name) => name in routeParams ? encodeURIComponent(routeParams[name]) : `:${name}`);
        const queryParts = (0, lodash_1.map)(query, (value, key) => `${key}=${encodeURIComponent(value)}`);
        return `${this.basePath}${(0, lodash_1.isEmpty)(queryParts) ? withRouteParams : `${withRouteParams}?${queryParts.join('&')}`}`;
    }
    buildRouteProperties({ type, screen, properties = {} }) {
        const { routeParams, headers, data, prefetch, fallback, query, state, events } = properties;
        if (type === 'pop' || type === 'dismiss')
            return undefined;
        const { path, method } = this.getPathAndMethod(screen);
        const url = this.buildUrl(path, routeParams, query);
        if (type === 'popTo')
            return { url };
        const routeProperties = {
            url,
            prefetch,
            method,
            headers,
            fallback,
            data,
            state,
            // @ts-ignore todo: this typing error
            events,
        };
        return routeProperties;
    }
    navigateRemote(navigation) {
        return navigationActions[navigation.type](this.buildRouteProperties(navigation));
    }
    // @ts-ignore todo: this typing error
    push = (...[screen, properties]) => this.navigateRemote({ type: 'push', screen, properties });
    pop = () => this.navigateRemote({ type: 'pop' });
    popTo = (...[screen, properties]) => this.navigateRemote({ type: 'popTo', screen, properties });
    // @ts-ignore todo: this typing error
    present = (...[screen, properties]) => this.navigateRemote({ type: 'present', screen, properties });
    dismiss = () => this.navigateRemote({ type: 'dismiss' });
}
exports.Navigator = Navigator;
