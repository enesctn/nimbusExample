"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = exports.sendRequest = void 0;
const lodash_1 = require("lodash");
const state_node_1 = require("../model/state/state-node");
const core_action_1 = require("./core-action");
const sendRequestAction = (0, core_action_1.createCoreAction)('sendRequest');
/**
 * Makes an HTTP request to the given address. By default the request is a "get", but the method, headers and body can
 * be customized via the parameters options.url, options.method, options.headers and options.data.
 *
 * When the request finishes, the event onSuccess or onError is triggered, depending on the result. After that, onFinish
 * is triggered anyway.
 *
 * OnSuccess and onError must be action factories, i.e. they must be a function that returns all actions that must be
 * run once the event is triggered. The onSuccess event needs a function that receives the successful result as
 * parameter. The onError needs a function that receives the failed result as parameter. For more information, check
 * {@link EnhancedSendRequestParams}.
 *
 * The onFinish event is not a function, the actions must be given directly, it should not depend on the result.
 *
 * @example:
 * ```typescript
 * interface User {
 *   name: string,
 *   age: number,
 * }
 *
 * const loading = createState('loading', false)
 *
 * const loadUser = [
 *   loading.set(true),
 *   sendRequest<User, string>(
 *     url: 'https://myapi.com/user/1'
 *     onSuccess: (response) => alert(`Username is ${response.get('data').get('name')}`),
 *     onError: (response) => alert(`An error occurred. ${response.get('data')}`),
 *     onFinish: loading.set(false),
 *   ),
 * ]
 * ```
 *
 * @category Actions
 * @param options the parameters of the sendRequest action: url, method, headers, data, onSuccess, onError and onFinish.
 * See {@link EnhancedSendRequestParams} and {@link BaseSendRequestParams} for more details.
 * @returns an instance of Action
 */
function sendRequest({ onError, onSuccess, ...other }) {
    const onErrorResult = onError ? onError((0, state_node_1.createStateNode)('onError')) : undefined;
    const onSuccessResult = onSuccess ? onSuccess((0, state_node_1.createStateNode)('onSuccess')) : undefined;
    return sendRequestAction({ onError: onErrorResult, onSuccess: onSuccessResult, ...other });
}
exports.sendRequest = sendRequest;
const sendRequestKeys = [
    'data', 'headers', 'method', 'onError', 'onFinish', 'onSuccess', 'url',
];
/**
 * This function can be used to compose a sendRequest action.
 *
 * Let's say we want function to fetch the product of id "prd-01". We generally don't wanna mix UI with network, so,
 * instead of calling sendRequest directly with the url to the backend, we create a function called fetchProductById
 * that receives the productId and the others options and create the send request action.
 *
 * The idea here is to let the developer compose a sendRequest action, instead of passing every parameter at once. In
 * the example below, we set both the url and method options of the send request, so the final function (value of
 * fetchProductById) only needs the remaining options.
 *
 * You can still say what's the response type and error with generics.
 *
 * @example
 * ```typescript
 * interface Options {
 *   id: string,
 * }
 *
 * export const fetchProductById = request<Product>()
 *  .compose(({ id }: Options) => ({ url: `https://myserver.com/data/products/${id}`, method: 'Get' }))
 * ```
 *
 * Now, in the UI code, `fetchProductById` can be used by only passing the id, no url or method are needed:
 *
 * ```
 * const MyScreen = () => (
 *   <Container onInit={fetchProductById({ id: 5, onSuccess: response => alert(product.title) })} />
 * )
 * ```
 *
 * @returns a composable request
 */
function request() {
    const compose = curryFn => (options) => {
        const curryOptions = curryFn(options);
        const allOptions = { ...options, ...curryOptions };
        const sendRequestOptions = (0, lodash_1.pick)(allOptions, sendRequestKeys);
        return sendRequest(sendRequestOptions);
    };
    return {
        /**
         * Use this function to compose a request.
         *
         * Please check {@link request} for more details.
         *
         * @param curryFn function to create the options for the sendRequest action
         * @returns a function to create a sendRequest action
         */
        compose,
    };
}
exports.request = request;
