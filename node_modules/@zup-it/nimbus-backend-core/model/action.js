"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAction = exports.Action = void 0;
class Action {
    static ACTION_TYPE = 'action';
    /**
     * @param options the action parameters: namespace, name, properties. See {@link Action}.
     */
    constructor({ name, namespace, properties }) {
        this.name = name;
        this.namespace = namespace;
        this.properties = properties;
        // @ts-ignore
        this._type = Action.ACTION_TYPE; // avoiding strange random behavior where instanceof doesn't work
    }
    static isAction(value) {
        return value instanceof Action || value?._type === Action.ACTION_TYPE;
    }
}
exports.Action = Action;
/**
 * Creates an {@link Action} Factory based on the properties passed in the generic. See the example below:
 * ```typescript
 * interface MyAlert {
 *   title?: Expression<string>,
 *   message: Expression<string>,
 *   icon?: string,
 * }
 *
 * export const myAlert = createAction<MyAlert>('my-alert', 'custom')
 * ```
 *
 * This creates a correctly typed Action factory that generates Action instances for the custom action "my-alert". To
 * use it in your screen, just call `myAlert`:
 *
 * ```tsx
 * <Button onPress={myAlert({ title: 'Hi!', message: 'Welcome to my app!', icon: 'happy-face'})}>Click me!</Button>
 * ```
 *
 * @param name the name for this action. Actions in nimbus are identified by a string in the format "$namespace:$name",
 * e.g "nimbus:alert".
 * @param namespace the namespace for this action.
 * @returns an Action Factory
 */
const createAction = (name, namespace) => ({ ...properties }) => new Action({ name, namespace, properties: properties });
exports.createAction = createAction;
